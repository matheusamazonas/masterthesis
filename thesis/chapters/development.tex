
\section{Changes to mTask}
\subsection{Variables}

Since \gls{mTask} is an imperative language, it would benefit from mutable data features. Although there are no \gls{mTask} constructs to represent variables, \acp{sds} might be used as updatable data containers. In such a setting, an \ac{sds} is created for each desired variable. This trick brings updatable data storage to \gls{mTask}, but it prompts two problems. 

First, there is no separation of concerns. Variables and \acp{sds} are by definition, different things. A variable is a \textit{local} updatable data storage in memory. An \ac{sds} is an abstraction layer over any kind of data that might be shared, including data in memory. Using an \ac{sds} locally goes against what a \textit{shared} data source represents. Second, \acp{sds} are sent to devices but they are not attached to a specific task. Also, on the current version of mTask, there is no way to establish whether an \ac{sds} belongs to a given task. As a consequence, \acp{sds} are never deleted from devices. Variables, on the other hand, are always bond to a specific task and could be removed with their correspondent task altogether, saving device memory. Thus, \gls{mTask} could benefit from a language construct for variables. 

The \texttt{vari} class was created to fill this gap. It contains two functions: \texttt{vari} and \texttt{con}, representing variable and constant data storage respectively. Its definition can be seen in Listing \ref{vari_class}. From a language construct point of view, the \texttt{sds} and \texttt{vari} classes do not differ much. Both classes contain constructs that might be used as updatables and as expressions. But there are two differences between these classes. First, \texttt{vari} contains a construct for constant data: \texttt{con}. Second, \texttt{vari} functions expect a value of type \texttt{t} as its initial value (seen as the first argument of \texttt{In} in Listing \ref{vari_class}). The \texttt{sds} function expects a \texttt{Shared t} instead. The biggest difference between the \texttt{sds} and \texttt{vari} classes regards their behavior on the interpreted view of \gls{mTask}. Variables belong to a task and will live as long as the task lives. \acp{sds} are not bound to a task and will live in the device indefinitely. 


\begin{lstlisting}[caption=The \texttt{vari} class,captionpos=b,label=vari_class]
:: Vari  = Vari
instance isExpr Vari where ...
instance isUpd Vari where ...

class vari v where
  vari :: ((v t Vari) -> In t (Main (v c s))) -> (Main (v c s)) 
  con ::  ((v t Expr) -> In t (Main (v c s))) -> (Main (v c s))
\end{lstlisting}

Listing \ref{vari_example} displays an example of the usage of variables in \gls{mTask}, the task \texttt{blink}. This task blinks \texttt{LED1} based on the value of variable \texttt{v}. The variable \texttt{v} is created using the \texttt{vari} construct. Its value is updated using the \texttt{=.} infix operator, similarly to \acp{sds}. It cal also be used as an boolean expression, as the condition to an \texttt{IF} construct.

\begin{lstlisting}[caption=Example of the usage of variables in mTask,captionpos=b,label=vari_example]
blink :: Main (v () Stmt) | program v
blink = vari \v = False In { main =
	IF (v) (
		ledOn (lit LED1)
	) (
		ledOff (lit LED1)
	) :.
	v =. Not v :. noOp
	}
\end{lstlisting}

The addition of variables to the language required changes on \gls{mTask}'s communication protocol (Section \ref{sec:mtask_com_prot}). When a task is sent to a device, its variables must be sent as well. Therefore, a \texttt{MTTask} message must include the variables used by the given task. Variables are modelled in the \texttt{BCVariable} record. A variable contains a unique (within a task) identifier and its initial value. The \texttt{BCVariable} record and the change in the communication protocol can be seen in Listing \ref{vari_message}.

\begin{lstlisting}[caption=Changes in mTask's communication protocol to accommodate task variables,captionpos=b,label=vari_message]
:: BCVariable = { vid :: Int, vval :: BCValue }

:: MTaskMSGSend
	= MTTask Int MTaskInterval [BCVariable] String
	 ...
\end{lstlisting}

Additionally, the simulator and the client engine were modified to support task variables. When a task is received, its variables are saved into memory. During task execution, variables are fetched and assigned similarly to \acp{sds}. When a task terminates, its variables are removed from memory.

\subsection{Peripherals}
\subsection{Device Requirements}

Some tasks rely on certain peripherals to execute. For example, a task that regulates room temperature relies on a temperature sensor. Despite that, \gls{mTask} does not provide a mechanism to determine whether a task is compatible with a device. The \texttt{Requirements} view was created to bring this feature to \gls{mTask}. Its definition can be seen in Listing \ref{lis:requirements}. \texttt{Requirement} is a type constructor with two phantom type variables: \texttt{a} and \texttt{b}~\cite{phantom}. These type variables are required by the \gls{mTask} type classes. A \texttt{Requirement} is a wrapper around the device specification type \texttt{MTaskDeviceSpec}. 

Given a \gls{mTask} construct, this view will return the minimum device specification necessary to support that construct. We can use that information do determine whether a device matches the minimum specification for a task and therefore, if it is compatible with it. The \texttt{match} function does exactly this. Given an \gls{mTask} program and a \texttt{Maybe MTaskDeviceSpec}, it yields whether the device is task is compatible with the device.

\begin{lstlisting}[caption=The \texttt{Requirements} view,captionpos=b,label=lis:requirements]
:: Requirements a b = Req MTaskDeviceSpec

match :: (Main (Requirements a b)) (Maybe MTaskDeviceSpec) -> Bool

instance arith Requirements ...
instance UserLED Requirements ...
...
\end{lstlisting}

Instances of the \gls{mTask} classes (including peripheral classes) are defined for \texttt{Requirement}. Therefore, given a task, an application can filter the available devices based on whether they are compatible with it. The opposite is also possible. Given a device, an application can filter tasks based on whether they are compatible with it.

\subsection{Device Disconnection}

\gls{autohouse} should be robust regarding device disconnection by design (Section \ref{sec:app_analysis}). Ideally, the system would detect a device disconnection and migrate the device's tasks to another suitable device. There were two challenges to tackle in order to implement this feature. 

First, \gls{mTask} does not recognize device disconnection for all of the device types it supports. Simulators never get disconnected. \acs{tcp} devices throw an \gls{iTasks} error when a disconnection is identified. This error is not caught by mTask and propagates upwards. Serial devices kill the application when disconnected. The library used by \gls{mTask} to connect to Serial devices (CleanSerial\footnote{CleanSerial on GitLab. Available at \url{git@gitlab.science.ru.nl:mlubbers/CleanSerial.git}. Accessed on Semtember 8th 2018}) halts execution when a device is disconnected. 

In order to detect device disconnection, \gls{mTask} had to be modified. If the device communication fails, the \texttt{channelSync} task (Section \ref{sec:mtask_devices}) should throw an exception\footnote{An \gls{iTasks} Task yields either a value or an exception. The \gls{iTasks} standard library provides functions to create and handle exceptions.}. \acs{tcp} devices already throw an exception when communication fails and therefore require no change. Although simulators never disconnect from the system, simulating a disconnection would benefit testing. Hence, simulators were modified to support intentional disconnection. CleanSerial was modified to support device disconnection recognition. At this point, \gls{mTask} recognizes device disconnection, but does not communicate it to \gls{autohouse}. 

Ideally, \gls{mTask} would communicate device disconnection through an error handler that would be provided by the application. Thus, the application would decide what task to perform in case of a device disconnection. As seen in Section \ref{sec:mtask_devices}, the \gls{mTask} library provides a single function to connect with a device: \texttt{withDevice}. This function is responsible (besides other tasks) to manage the connection to the device. It was modified to accommodate an exception handler. Listing \ref{with_device} displays the type signature of the original \texttt{withDevice} along with its new version, named \texttt{withDevice'} here.

\begin{lstlisting}[caption=Change in mTask to allow device disconnection handler,captionpos=b,label=with_device]
withDevice  :: a (MTaskDevice -> Task b)                    -> Task b | channelSync a

withDevice' :: a (MTaskDevice -> Task b) (String -> Task ()) -> Task b | channelSync a
\end{lstlisting}

Consequently, \gls{mTask} recognizes and provides an exception handler for device disconnection. \gls{autohouse} uses this feature to detect Unit disconnection and thus automatically migrate tasks from the disconnected device to a suitable one.

\subsection{Simulator Improvements}

The simulator (Section \ref{mtask_simulator}) proved to be an essential tool during the development of \gls{autohouse}. Although, it was clear that it could be improved to ease debug and testing of the application. 

Sometimes, the developer might want to debug a task and inspect it closely. The simulator's manual mode is adequate for such usage, but it might be a bit cumbersome to use. Specially with large tasks, stepping over each program instruction becomes a rather tedious and inefficient process. With that in mind, the simulator was extended to support breakpoints on bytecode instructions. Tools to add and to step over breakpoints were added to the simulator \acs{ui}. When executing a task, the simulator goes through its bytecode instructions, checking if there are breakpoints on each instruction before executing it. If an instruction has a breakpoint, execution awaits for user input (by clicking on "step over") to continue. At any point, the user is able to edit breakpoints. 

The ability to simulate peripheral values is crucial for program testing in \gls{mTask}. Tasks often rely on peripheral values and therefore can only be thoroughly tested if peripheral values can be simulated. Although, the simulator did not have such feature. The development of \gls{autohouse} showed how necessary this feature is for \gls{mTask} development. Hence, simulation of peripheral values was incorporated to the simulator. Values can be manually set via the simulator \acs{ui}, similarly to breakpoints. 

\section{Prototyping Using the Simulator}

\section{Device Deployment}
\subsection{Devices}
\subsection{Communication}
\subsection{Sensors}
\subsection{Actuators}
