\section{Development Overview}
\subsection{Application Architecture}
\subsection{Using the Simulator}
\subsection{Device Deployment}
\subsubsection{Devices}
\subsubsection{Peripherals}-
\subsubsection{Communication}

\section{Changes to mTask}
\subsection{Variables}

Since \gls{mTask} is an imperative language, it would benefit from mutable data features. Although there are no \gls{mTask} constructs to represent variables, \acp{sds} might be used as updatable data containers. In such a setting, an \ac{sds} is created for each desired variable. This trick brings updatable data storage to \gls{mTask}, but it prompts two problems. 

First, there is no separation of concerns. Variables and \acp{sds} are by definition, different things. A variable is a \textit{local} updatable data storage in memory. An \ac{sds} is an abstraction layer over any kind of shared data, including data in memory. Using an \ac{sds} locally goes against what a \textit{shared} data source represents. Second, when \acp{sds} are sent to devices, they are not attached to a specific task. Also, on the current version of \gls{mTask}, there is no way to establish whether an \ac{sds} belongs to a given task. As a consequence, \acp{sds} are never deleted from devices. Variables, on the other hand, are always bond to a specific task and could be removed with their correspondent task altogether, saving space in the device's memory. Thus, \gls{mTask} could benefit from a language construct for variables. 

The \texttt{vari} class was created to fill this gap. It contains two functions: \texttt{vari} and \texttt{con}, representing variable and constant data storage respectively. Its definition can be seen in Listing \ref{vari_class}. From a language construct point of view, the \texttt{sds} and \texttt{vari} classes do not differ much. Both classes contain constructs that might be used as updatables and as expressions. But there are two differences between these classes. First, \texttt{vari} contains a construct for constant data: \texttt{con}. Second, \texttt{vari} functions expect a value of type \texttt{t} as its initial value (seen as the first argument of \texttt{In} in Listing \ref{vari_class}). The \texttt{sds} function expects a \texttt{Shared t} instead. The biggest difference between the \texttt{sds} and \texttt{vari} classes regards their behavior on the interpreted view of \gls{mTask}. Variables belong to a task and will live as long as the task lives. \acp{sds} are not bound to a task and will live in the device indefinitely. 


\begin{lstlisting}[caption=The \texttt{vari} class,captionpos=b,label=vari_class]
:: Vari  = Vari
instance isExpr Vari 
instance isUpd Vari 

class vari v where
  vari :: ((v t Vari) -> In t (Main (v c s))) -> (Main (v c s)) 
  con ::  ((v t Expr) -> In t (Main (v c s))) -> (Main (v c s))
\end{lstlisting}

Listing \ref{vari_example} displays an example of variables in \gls{mTask}: the task \texttt{blink}. This task blinks \texttt{LED1} based on the value of variable \texttt{v}. The variable \texttt{v} is created using the \texttt{vari} construct. Its value is updated using the \texttt{=.} infix operator, similarly to \acp{sds}. It can also be used as a boolean expression, as the condition to an \texttt{IF} construct.

\begin{lstlisting}[caption=Example of the usage of variables in mTask,captionpos=b,label=vari_example]
blink :: Main (v () Stmt) | program v
blink = vari \v = False In { main =
	IF (v) (
		ledOn (lit LED1)
	) (
		ledOff (lit LED1)
	) :.
	v =. Not v :. noOp
	}
\end{lstlisting}

The addition of variables to the language required changes on \gls{mTask}'s communication protocol (Section \ref{sec:mtask_com_prot}). When a task is sent to a device, its variables must be sent as well. Therefore, a \texttt{MTTask} message must include the variables used by the given task. Variables are modelled in the \texttt{BCVariable} record. A variable contains a unique (within a task) identifier and its initial value. The \texttt{BCVariable} record and the communication protocol change can be seen in Listing \ref{vari_message}.

\begin{lstlisting}[caption=Change in mTask's communication protocol to accommodate task variables,captionpos=b,label=vari_message]
:: BCVariable = { vid :: Int, vval :: BCValue }

:: MTaskMSGSend
	= MTTask Int MTaskInterval [BCVariable] String
	 ...
\end{lstlisting}

Additionally, the simulator and the client engine were modified to support task variables. When a task is received, its variables are stored. During task execution, variables are fetched and assigned similarly to \acp{sds}. When a task terminates, its variables are removed from the device.

\subsection{Peripherals}

The \gls{mTask} library already supported some of the peripherals \gls{autohouse} planned to use: \acsp{led}, analog and digital pins. Although, new peripherals (e.g. light, temperature and humidity sensors) had to be added to implement some of the proposed automation tasks. Following the natural development process of an \gls{mTask} application, these peripherals were first emulated using the simulator. As more peripherals were implemented, it was clear that the workflow required to add a new peripheral to the system could be improved.

Adding a new peripheral requires changes on different parts of \gls{mTask}. An overview of the necessary changes can be seen below.

\begin{itemize}
    \item A new class that represents the peripheral is added to the language. 
    \item Depending on the peripheral, a new \ac{adt} is created to represent its values (e.g. \texttt{DigitalPin}).
    \item New bytecode instructions are created.
    \item Bytecode encodings are updated to support the new instruction and the possibly new \acs{adt}.
    \item The \texttt{MTaskDeviceSpec} record is updated to include a flag for the new peripheral.
    \item The simulator interpreter is updated to handle new bytecode instructions.
    \item The \gls{cpp} client is updated to handle the new peripheral.
\end{itemize}

The changes on the \gls{cpp} client code depended heavily on the type of peripheral being implemented. Changes on the \gls{clean} code though, were often similar. Previously, peripheral code was scattered around the \gls{mTask} library. Peripheral classes were inside the \texttt{Language} module along with possibly new \acsp{adt}. Instances of the peripheral classes for each \gls{mTask} view were in the respective view's module. The simulator interpreter contained peripheral-specific code. Bytecode encodings for basic types were mixed with encodings for peripheral data types. Overall, adding a new peripheral was particularly cumbersome and extremely error-prone. Finally, there was no separation of concerns whatsoever.

A new modular code architecture for peripherals was introduced to solvethe problems described above. Each peripheral should be defined in its own module. Its type class, \acsp{adt}, bytecode encodings and view instances are defined in that same module. The simulator does not have any peripheral-specific code. Instead of explicit fields for each peripheral, the simulator state record (\texttt{SimState}) contains a list of \texttt{Peripheral}. This new data type is a wrapper around every \gls{mTask} peripheral. Its definition can be seen in Listing \ref{lis:peripheral}. 

\begin{lstlisting}[caption=The \texttt{Peripheral} class,captionpos=b,label=lis:peripheral]
:: Peripheral = E.e: Peripheral e & peripheral e

class peripheral e | iTask e where
	processInst :: BC e -> State SimState (e,Bool)
\end{lstlisting}

The \texttt{peripheral} class was created to enable the removal of peripheral-specific code from the simulator interpreter. Its only function, \texttt{processInst} defines how a peripheral should interpret bytecode instructions (\texttt{BC}). Naturally, a peripheral should only interpret instructions that are relevant to it. The simulator interpreter executes one instruction at a time. If an instruction belongs to \gls{mTask}'s core instruction set (excluding peripheral instructions), the interpreter executes it immediately. If the instruction does not belong to the core instruction set, it is assumed to be a peripheral instruction and it is presented to all simulator peripherals using the \texttt{processInst} function. Once a peripheral responds to an instruction (represented by the \texttt{Bool} on \texttt{processInst} returned value), the interpreter considers the instruction executed and stops looking for a peripheral to execute it. If no peripheral executes the instruction, an error ("instruction unknown") is thrown. 

The addition of new bytecode instructions remains outside of the peripheral module. Although technically it is possible to extend the bytecode data type (\texttt{BC}) in seperate modules, the amount of work necessary to do so outweighed the benefits it could bring. 

The development that followed the changes described above proved that the separation of concerns regarding peripheral code improved \gls{mTask}. Peripherals were added faster, with less code changes and less errors. Additionally, code maintainability increased substantially. Since peripheral code lays mostly in the same module, small changes can be performed faster and safer.

\subsection{Device Requirements}

Some tasks rely on certain peripherals to execute. For example, a task that regulates room temperature relies on a temperature sensor. Despite that, \gls{mTask} does not provide a mechanism to determine whether a task is compatible with a device. The \texttt{Requirements} view was created to bring this feature to \gls{mTask}. Its definition can be seen in Listing \ref{lis:requirements}. \texttt{Requirement} is a type constructor with two phantom type variables: \texttt{a} and \texttt{b}~\cite{phantom}. These type variables are required by the \gls{mTask} type classes. \texttt{Requirement} is a wrapper around the device specification type \texttt{MTaskDeviceSpec}. 

Given a \gls{mTask} construct, this view will return the minimum device specification necessary to support that construct. We can use that information do determine whether a device matches the minimum specification for a task and therefore, if it is compatible with it. The \texttt{match} function does exactly that. Given an \gls{mTask} program and a \texttt{Maybe MTaskDeviceSpec}, it yields whether the device and program are compatible.

\begin{lstlisting}[caption=The \texttt{Requirements} view,captionpos=b,label=lis:requirements]
:: Requirements a b = Req MTaskDeviceSpec

match :: (Main (Requirements a b)) (Maybe MTaskDeviceSpec) -> Bool

instance arith Requirements
instance UserLED Requirements 
\end{lstlisting}

Instances of \gls{mTask} classes (including peripheral classes) are defined for \texttt{Requirement}. Therefore, given a task, an application can filter the available devices based on whether they are compatible with it. The opposite is also possible: given a device, an application can filter tasks based on whether they are compatible with it.

\subsection{Device Disconnection}

By design, \gls{autohouse} should be robust regarding device disconnection (Section \ref{sec:app_analysis}). Ideally, the system would detect a device disconnection and migrate the device's tasks to another suitable device. There were two challenges to tackle in order to implement this feature. 

First, \gls{mTask} does not recognize device disconnection for all of the device types it supports. Simulators never get disconnected. \acs{tcp} devices throw an \gls{iTasks} error when a disconnection is identified. This error is not caught by mTask and propagates upwards. Serial devices kill the application when disconnected. The library used by \gls{mTask} to connect to Serial devices (CleanSerial\footnote{CleanSerial on GitLab. Available at \url{git@gitlab.science.ru.nl:mlubbers/CleanSerial.git}. Accessed on Semtember 8th 2018}) halts execution when a device is disconnected. 

In order to detect device disconnection, \gls{mTask} had to be modified. If the device communication fails, the \texttt{channelSync} task (Section \ref{sec:mtask_devices}) should throw an exception\footnote{An \gls{iTasks} Task yields either a value or an exception. The \gls{iTasks} standard library provides functions to create and handle exceptions.}. \acs{tcp} devices already throw an exception when communication fails and therefore require no change. Although simulators never disconnect from the system, simulating a disconnection would benefit testing. Hence, simulators were modified to support intentional disconnection. CleanSerial was modified to support device disconnection recognition. At this point, \gls{mTask} recognizes device disconnection, but does not communicate it to \gls{autohouse}. 

Ideally, \gls{mTask} would communicate device disconnection through an error handler that would be provided by the application. Thus, the application would decide what task to perform in case of a disconnection. As seen in Section \ref{sec:mtask_devices}, the \gls{mTask} library provides a single function to connect with a device: \texttt{withDevice}. This function is responsible (besides other tasks) to manage the connection to the device. It was modified to accommodate an exception handler. Listing \ref{with_device} displays the type signature of the original \texttt{withDevice} along with its new version, named \texttt{withDevice'} here.

\begin{lstlisting}[caption=Change in mTask to allow device disconnection handler,captionpos=b,label=with_device]
withDevice  :: a (MTaskDevice -> Task b)                    -> Task b | channelSync a

withDevice' :: a (MTaskDevice -> Task b) (String -> Task ()) -> Task b | channelSync a
\end{lstlisting}

Consequently, \gls{mTask} recognizes and provides an exception handler for device disconnection. \gls{autohouse} uses this feature to detect Unit disconnection and thus automatically migrate tasks from the disconnected device to a suitable one.

\subsection{Simulator Improvements}

The simulator (Section \ref{mtask_simulator}) proved to be an essential tool during the development of \gls{autohouse}. Although, it was clear that it could be improved to ease debug and testing of the application. 

Sometimes, the developer might want to debug a task and inspect it closely. The simulator's manual mode is adequate for such usage, but it might be a bit cumbersome to use. Specially with large tasks, stepping over each program instruction becomes a rather tedious and inefficient process. With that in mind, the simulator was extended to support breakpoints on bytecode instructions. Tools to add and to step over breakpoints were added to the simulator \acs{ui}. When executing a task, the simulator goes through its bytecode instructions, checking if there are breakpoints on each instruction before executing it. If an instruction has a breakpoint, execution awaits for user input (by clicking on "step over") to continue. At any point, the user is able to edit breakpoints. 

The ability to simulate peripheral values is crucial for program testing in \gls{mTask}. Tasks often rely on peripheral values and therefore can only be thoroughly tested if peripheral values can be simulated. Although, the simulator did not have such feature. The development of \gls{autohouse} showed how necessary this feature is for \gls{mTask} development. Hence, simulation of peripheral values was incorporated to the simulator. Values can be manually set via the simulator \acs{ui}, similarly to breakpoints. 

\section{Task Migration}

