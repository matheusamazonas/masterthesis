Recent research has been conducted on mTask. A new, task-based version of it has been proposed~\cite{micro}. On this version, the imperative language has been replaced by a functional one. This new version was not used during the research reported in this document because its implementation was not available on time.

The usage of programming languages to interface with microcontrollers has been a subject of research. Firmata\footnote{Firmata Protocol Documentation. Available at \url{https://github.com/firmata/protocol}. Accessed on August 10th 2018.} is a protocol to control microcontrollers. Its messages follow the \acs{midi} message format and model mostly commands on analog and digital input and output pins. There is a client-side implementation for the Arduino\footnote{Firmara Arduino. Available at \url{https://github.com/firmata/arduino}. Accessed on August 10th 2018.} and host-side implementations for many programming languages, including a Haskell implementation to communicate with Arduinos called hArduino\footnote{hArduino. Available at \url{http://leventerkok.github.io/hArduino}. Accessed on August 10th 2018.}. Since Firmata is a protocol and not a programming language, full applications can not be built using Firmata solely. Other tools are built on top of it.

The Haskino library enables Arduino programming using Haskell~\cite{haskino}. The library is available in two different flavors. The first one is based on hArduino (and consequently, on Firmata) and requires the Arduino to maintain a serial connection with the host. On this approach, most of the program evaluation is executed on the host and only I/O commands run on the client. The second approach drops Firmata and uses its own communication protocol. The client is more independent and can execute more elaborate commands, including control flow constructs. In contrast with the first approach, it presents a lower communication overhead. In addition, programs can be written to the Arduino's \acs{eeprom}, allowing standalone execution.

Some research has been made on generating C/C++ code for microcontrollers from high level languages. Ivory is an \ac{edsl} embedded into Haskell that generates safe embedded C code~\cite{ivory1,ivory2}. By design, the generated code is memory safe and free from common errors and undefined behaviors. It uses Haskell's type system (with some \acs{ghc} extensions) to avoid errors like array indexing out of bounds, main loop function with return statements and dangling pointers. Additionally, it prohibits (by design) some standard C features that might generate unsafe code. Ivory was used on the development of the SMACCPilot, a high-assurance autopilot system for quadcopter \ac{uav}.

The \texttt{frp-arduino} library\footnote{\acs{frp} on Arduino. Available at \url{https://github.com/frp-arduino/frp-arduino}. Accessed on August 10th 2018.} implements the \ac{frp} paradigm as an \ac{edsl} embedded in Haskell. Programs in the \ac{edsl} can be compiled to Arduino C code which can be uploaded to Arduino boards. Juniper\footnote{Juniper Programming Language. Available at \url{http://www.juniper-lang.org/index.html}. Accessed on August 11th 2018.} is another \ac{frp} language for the Arduino. It is a standalone programming language that transpiles to Arduino C++.

Additionally, some programming language interpreters were ported to microcontrollers. Espruino\footnote{Espruino. Available at \url{https://www.espruino.com}. Accessed on August 10th 2018.} is a JavaScript interpreter for microcontrollers. It officially supports only proprietary boards but other microcontrollers such as the ESP8266 and the members of the STM32 family are supported by the community. Due to hardware limitations, none of the Arduino boards are supported. Espruino's official website lists many projects that were built using it, including home automation applications. 

Micropython\footnote{Micropytohn. Available at \url{https://micropython.org}. Accessed on August 10th 2018.} is a lean implementation of the Python interpreter and parts of its standard library for microcontrollers. Its main target device is the proprietary \textit{pyboard}. Given that it requires at least 16KB of RAM, it is not compatible with most Arduino boards. It is compatible with microcontrollers of the STM32 family. Many projects (including home automation) were developed using Micropython and \textit{pyboards}. 

Finally, the programming of microcontrollers dynamically (without the need to plug it to a computer) is a well known practice. For example, the ESP8266\footnote{ESP8266 Overview. Available at \url{https://www.espressif.com/en/products/hardware/esp8266ex/overview}. Accessed at August 11th 2018.} Wi-Fi module supports \ac{ota} programming. The Arduino Uno Wi-Fi\footnote{Arduino Store - Arduino Uno Wi-Fi. Available at \url{https://store.arduino.cc/arduino-uno-wifi}. Accessed on August 11th 2018.} is a version of the Arduino Uno board that contains an ESP8266 module and supports \ac{ota} programming natively via the Arduino \acs{ide}. It is important to note that although \ac{ota} enables dynamic programming of microcontrollers, it differs from mTask's dynamicity. On \ac{ota} programming, the device memory is reset when a new program is loaded. On the dynamic version of mTask, the device's memory and the tasks running on it are unaffected.