In some cases, interactions between the iTasks system and the real world could be automated. This is the case for tasks such as reading the room temperature or turning a LED on once a task is completed. Microcontrollers --- such as Arduino --- are perfect for this kind of task. They are great for control tasks that involve reading sensors (e.g., temperature, light) and controlling actuators (e.g., motors, LEDs). In addition, due to the growth of \ac{iot}, they are becoming increasingly cheaper. Due to hardware limitations, microcontrollers can not run iTasks tasks. As an alternative, the mTask \ac{edsl} was created. This \ac{dsl} allows the programming of microcontrollers in Clean using a TOP-like approach~\cite{clean,mtasks,mtasks2,martthesis}.

The mTask \ac{dsl} is a type safe, class-based, multi-view \ac{edsl} (\autoref{sec:class_based_edsl}). It currently has three views: iTasks simulation, C code generation and interpretable bytecode generation.

\section{The Language}
Since mTask is an \ac{edsl}, language constructs are represented as functions in the host language. Instead of using functions directly, mTasks is composed by type constructor classes, as described in \autoref{sec:class_based_edsl}. A mTask type constructor class can be seen on Listing \ref{mtask_class}. In this example, the \texttt{arith} class is partially presented. An overview of mTask classes will be presented in Section \ref{mtask_classes}.

\begin{lstlisting}[caption=A mTask class,captionpos=b,label=mtask_class]
class arith v where
    lit :: t -> v t Expr                             | mTaskType t                       
    (+.) infixl 6 :: (v t p) (v t q) -> v t Expr     | type, +, t & isExpr p & isExpr q
\end{lstlisting}

The \texttt{lit} function lifts a value to the mTask domain. The \texttt{+.} infix operator adds two expressions (represented by the \texttt{isExpr} class constraint) and returns another expression. The constraints \texttt{type} and \texttt{mTaskType} ensure that only mTask types can be used. Language constructs are of the form \texttt{v t p} where \texttt{v} is the view, \texttt{t} is the type of the construct and \texttt{p} is the the construct kind. The constructor kind is a phantom \ac{adt} that specifies whether the constructor is an updatable, an expression or a statement~\cite{mtasks2}. The definitions of the constructor kinds and the \texttt{isExpr} class along with its instances can be seen in Listing \ref{mtask_kinds}.

\begin{lstlisting}[caption=mTask construction kinds, captionpos=b,label=mtask_kinds]
:: Upd   = Upd
:: Expr  = Expr
:: Stmt  = Stmt

class isExpr a :: a
instance isExpr Upd
instance isExpr Expr
\end{lstlisting}

Views implement instances of mTask classes. Due to the multi-class nature of mTask, a view can choose which language constructs it supports by selecting which class instances to implement. Moreover, new language constructs can be added to the language without the need to change existing code. 


\subsection{Overview of the classes}\label{mtask_classes}

The mTask \ac{edsl} is formed by many type constructor classes. Here, only the classes that are most relevant to the thesis are presented. Some class constraints were omitted to ease understanding.

\paragraph{Expression:} There are two classes to create expressions in mTask: \texttt{arith} and \texttt{boolExpr}. They model constructs for arithmetic and boolean expressions, respectively. The \texttt{arith} class contains operators for addition, multiplication, subtraction and division in addition to a function to lift values to the mTask domain. The \texttt{boolExpr} contains operators over booleans (e.g., conjunction, disjunction) in addition to equality and inequality operators. Shortened versions of these classes can be seen in Listing \ref{mtask_expr}. 

\begin{lstlisting}[caption=mTask expression classes,captionpos=b,label=mtask_expr]
class arith v where
	lit :: t -> v t Expr 
	(+.) infixl 6 :: (v t p) (v t q) -> v t Expr | + t
	...

class boolExpr v where
	(&.) infixr 3 :: (v Bool p) (v Bool q) -> v Bool Expr 
	Not           :: (v Bool p)            -> v Bool Expr 
	(==.) infix 4 :: (v a p) (v a q)       -> v Bool Expr | == a
	(<.)  infix 4 :: (v a p) (v a q)       -> v Bool Expr | < a
	...
\end{lstlisting}

\paragraph{Control flow:} There are two classes that implement \textit{if} constructs in mTask: \texttt{If} ad \texttt{IF}. They implement different variations of \textit{if} constructs. Given that mTask tasks can be executed periodically, loop constructs are unnecessary and are not part of mTask. The \texttt{seq} class contains the the monadic bind operator (\texttt{>>=.}) for mTask. In addition, it contains a variant of the monadic operator where the result of its first argument is disregarded. This operator is equivalent to the semicolon in imperative languages. The \texttt{retrn} class contains a single function that terminates the task. Control flow classes can be seen in Listing \ref{mtask_contr}

\begin{lstlisting}[caption=mTask control flow classes,captionpos=b,label=mtask_contr]
class If v q r ~s where
  If :: (v Bool p) (v t q) (v t r) -> v t s      | isExpr p 
class IF v where
  IF :: (v Bool p) (v t q) (v s r) -> v () Stmt  | isExpr p
  (?) infix 1 :: (v Bool p) (v t q) -> v () Stmt | isExpr p
class seq v where
  (>>=.) infixr 0 :: (v t p) ((v t Expr) -> (v u q)) -> (v u Stmt) 
  (:.) infixr 0 :: (v t p) (v u q) -> v u Stmt 
class retrn v where
  retrn :: v () Expr
\end{lstlisting}

\paragraph{\aclp{sds}} The \texttt{sds} class contains functions to create \aclp{sds}. The \texttt{sds} function is used to create updatable \acp{sds} and the \texttt{con} function is used to create constant \acp{sds}. Both use the technique described in Section \ref{sec:class_based_edsl} to guarantee a type-safe usage of \acp{sds}. The \texttt{sdspub} class contains a construct to publish \acp{sds}. The \texttt{assign} contains a single function to enable assignment in mTask. \ac{sds} classes can be seen in Listing \ref{mtask_sds}. Notice the functions below enforce the construct kind \texttt{Upd} to ensure that only updatables are used.

\begin{lstlisting}[caption=mTask SDS classes,captionpos=b,label=mtask_sds]
:: In a b = In infix 0 a b

class sds v where
  sds :: ((v t Upd)  -> In t (Main (v c s))) -> (Main (v c s))
  con :: ((v t Expr) -> In t (Main (v c s))) -> (Main (v c s)) 
class sdspub v where
  pub :: (v t Upd) -> v t Expr
class assign v where
  (=.) infixr 2 :: (v t Upd) (v t p) -> v t Expr | isExpr p
\end{lstlisting}

\paragraph{Input and output} There are constructs to handle both analog and digital input and output. The class \texttt{digitalIO} contains
functions for digital read and write on pins. These functions operate on booleans. Analogously, the \texttt{analogIO} class contains functions for analog read and write on pins.

\begin{lstlisting}[caption=mTask I/O classes,captionpos=b,label=mtask_io]
:: DigitalPin = D0 | D1 | D2 | D3 | D4 | D5 |D6 | D7 | D8 | D9 | D10 | D11 | D12 | D13
:: AnalogPin = A0 | A1 | A2 | A3 | A4 | A5
:: Pin = Digital DigitalPin | Analog AnalogPin

class pin p |  == p where
	pin :: p -> Pin
instance pin DigitalPin
instance pin AnalogPin

class digitalIO v where
  digitalRead  :: p -> v Bool Expr | pin p
  digitalWrite :: p (v Bool q) -> v Bool Expr | pin  p
class analogIO v where
  analogRead  :: AnalogPin -> v Int Expr 
  analogWrite :: AnalogPin (v Int p) -> v Int Expr
\end{lstlisting}


\subsection{Overview of the views}


\section{Interpreted mTask}

\section{Example}
