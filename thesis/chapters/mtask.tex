In some cases, interactions between the iTasks system and the real world could be automated. This is the case for tasks such as reading the room temperature or turning a LED on once a task is completed. Microcontrollers are perfect for this kind of task. They are cheap systems that great for control tasks that involve reading sensors (e.g., temperature, light) and controlling actuators (e.g., motors, LEDs). Due to hardware limitations, microcontrollers can not run iTasks tasks. As an alternative, the mTask \ac{edsl} was created. This \ac{dsl} allows the programming of microcontrollers in Clean using a TOP-like approach~\cite{micro,mtasks,martthesis}.

The mTask \ac{dsl} is a type safe, class-based, multi-view \ac{edsl} (Section \ref{sec:class_based_edsl}). It currently has three views: C++ code generation, evaluation and interpretable bytecode generation. An overview of the views is given in Section \ref{sec:mtask_views}.

\section{The Language}
Because mTask is a shallowly \ac{edsl}, language constructs are represented as functions in the host language. Instead of using functions directly, mTask is composed by type constructor classes, as described in Section \ref{sec:class_based_edsl}. A mTask type constructor class can be seen on Listing \ref{mtask_class}. In this example, the \texttt{arith} class is partially presented. An overview of mTask classes will be presented in Section \ref{sec:mtask_classes}.

\begin{lstlisting}[caption=A mTask class,captionpos=b,label=mtask_class]
class arith v where
    lit :: t -> v t Expr                             | mTaskType t                       
    (+.) infixl 6 :: (v t p) (v t q) -> v t Expr     | type, +, t & isExpr p & isExpr q
\end{lstlisting}

Language constructs are of the form \texttt{v t p} where \texttt{v} is the view, \texttt{t} is the type of the construct and \texttt{p} is the construct role. The \texttt{lit} function lifts a value to the mTask domain. The \texttt{+.} infix operator adds two expressions (represented by the \texttt{isExpr} class constraint) and returns another expression. The constraints \texttt{type} and \texttt{mTaskType} ensure that only mTask types can be used. The constructor role is an \ac{adt} that specifies whether the constructor is an updatable, an expression or a statement~\cite{mtasks,martthesis}. The definitions of the constructor roles and the \texttt{isExpr} class along with its instances can be seen in Listing \ref{mtask_roles}.

\begin{lstlisting}[caption=mTask construction roles, captionpos=b,label=mtask_roles]
:: Upd   = Upd
:: Expr  = Expr
:: Stmt  = Stmt

class isExpr a :: a
instance isExpr Upd
instance isExpr Expr
\end{lstlisting}

Views are instances of mTask classes. Due to the multi-class nature of mTask, a view can choose which language constructs it supports by selecting which classes it implements. Moreover, new language constructs can be added to the language without the need to change existing code. 


\subsection{Overview of the Classes}\label{sec:mtask_classes}

The mTask \ac{edsl} is formed by many type constructor classes. Here, only the classes that are most relevant to the research are presented. Some class constraints were omitted to ease understanding.

\paragraph{Expression:} There are two classes to create expressions in mTask: \texttt{arith} and \texttt{boolExpr}. They model constructs for arithmetic and boolean expressions, respectively. The \texttt{arith} class contains operators for addition, multiplication, subtraction and division in addition to a function to lift values to the mTask domain. The \texttt{boolExpr} contains operators over booleans (e.g., conjunction, disjunction) in addition to equality and inequality operators. Shortened versions of these classes can be seen in Listing \ref{mtask_expr}. 

\begin{lstlisting}[caption=mTask expression classes,captionpos=b,label=mtask_expr]
class arith v where
	lit :: t -> v t Expr 
	(+.) infixl 6 :: (v t p) (v t q) -> v t Expr | + t
	...

class boolExpr v where
	(&.) infixr 3 :: (v Bool p) (v Bool q) -> v Bool Expr 
	Not           :: (v Bool p)            -> v Bool Expr 
	(==.) infix 4 :: (v a p) (v a q)       -> v Bool Expr | == a
	(<.)  infix 4 :: (v a p) (v a q)       -> v Bool Expr | < a
	...
\end{lstlisting}

\paragraph{Control flow:} The \texttt{IF} class implements \textit{if} constructs. The \texttt{IF} function implements a \textit{if-then-else} statement and the \texttt{?} infix operator implements an \textit{if-then} statement. Given that mTask tasks can be executed periodically, loop constructs are unnecessary and are not part of mTask. The \texttt{seq} class contains the the monadic bind operator (\texttt{>>=.}) for mTask. In addition, it contains a variant of the monadic operator where the result of its first argument is disregarded. This operator is equivalent to the semicolon in imperative languages. The \texttt{retrn} class contains a single function that terminates the task. Control flow classes can be seen in Listing \ref{mtask_contr}

\begin{lstlisting}[caption=mTask control flow classes,captionpos=b,label=mtask_contr]
class IF v where
  IF :: (v Bool p) (v t q) (v s r)  -> v () Stmt | isExpr p
  (?) infix 1 :: (v Bool p) (v t q) -> v () Stmt | isExpr p
class seq v where
  (>>=.) infixr 0 :: (v t p) ((v t Expr) -> (v u q)) -> (v u Stmt) 
  (:.) infixr 0 :: (v t p) (v u q) -> v u Stmt 
class retrn v where
  retrn :: v () Expr
\end{lstlisting}

\paragraph{\aclp{sds}} The \texttt{sds} class contains functions to create \aclp{sds}. The \texttt{sds} function is used to create updatable \acp{sds} and the \texttt{con} function is used to create constant \acp{sds}. Both use the technique described in Section \ref{sec:class_based_edsl} to guarantee a type-safe usage of \acp{sds}. The \texttt{sdspub} class contains a construct to publish \acp{sds}. The \texttt{assign} class contains a single function to enable assignment in mTask. \ac{sds} classes can be seen in Listing \ref{mtask_sds}. Notice that the functions below enforce the construct role \texttt{Upd} to ensure that only updatables are used.

\begin{lstlisting}[caption=mTask SDS classes,captionpos=b,label=mtask_sds]
:: In a b = In infix 0 a b
:: Main a = {main :: a}

class sds v where
  sds :: ((v t Upd)  -> In t (Main (v c s))) -> (Main (v c s))
  con :: ((v t Expr) -> In t (Main (v c s))) -> (Main (v c s)) 
class sdspub v where
  pub :: (v t Upd) -> v t Expr
class assign v where
  (=.) infixr 2 :: (v t Upd) (v t p) -> v t Expr | isExpr p
\end{lstlisting}

\paragraph{Input and output} There are constructs to handle both analog and digital input and output. The classes \texttt{dIO} and \texttt{aIO} contain functions to handle digital and analog I/O, respectively. Both classes create updatables that can be used to read from and write to a pin. The \texttt{userLed} class contains functions to turn LEDs on an off. Input/output classes can be seen in Listing \ref{mtask_io}. 

\begin{lstlisting}[caption=mTask I/O classes,captionpos=b,label=mtask_io]
:: DigitalPin = D0 | D1 | D2 | D3 | D4 | D5 |D6 | D7 | D8 | D9 | D10 | D11 | D12 | D13
:: AnalogPin  = A0 | A1 | A2 | A3 | A4 | A5
:: Pin = Digital DigitalPin | Analog AnalogPin
:: UserLED   = LED1 | LED2 | LED3

class dIO v where
	dIO :: DigitalPin -> v Bool Upd
class aIO v where
	aIO :: AnalogPin  -> v Int Upd
class userLed v where
  ledOn  :: (v UserLED q) -> (v () Stmt)
  ledOff :: (v UserLED q) -> (v () Stmt)
\end{lstlisting}


\subsection{Overview of the Views}\label{sec:mtask_views}

Currently, mTask has three views: C++ code generation, evaluation and bytecode generation.

The C++ code generation view translates language constructs to Arduino's dialect of C++. The Arduino IDE compiles the C++ source code to machine code for the microcontrollers. 
It is convenient to generate C++ code instead of machine code because it saves us from the task of generating code for different microcontrollers. In addition, C++ gives us the level of control we need to handle low level input/output operations. This view consists of a function that modifies a compilation state, \texttt{CODE}. The state is a record that stores the generated code along with some information to generate identifiers and to keep track of source code indentation. At the end of compilation, the \texttt{CODE} record is transformed into C++ code which can be saved into disk, loaded into the Arduino IDE and uploaded to microcontrollers.


The evaluation view translates language constructs into Clean programs. It consists of a function that modifies an evaluation state. The state is a record that stores tasks, program variables and input/output information. Given that programs running on microcontrollers are hard to debug, one can benefit from this view to find program errors. This view can be used to build a mTask simulator using iTasks where the user can observe the state of the program on each loop of the microcontroller.

The last mTask view transforms language constructs into interpretable bytecode. Since the research focused on this view of mTask, it will be discussed in more detail in Section \ref{sec:int_mtask}.

\section{Interpreted mTask}\label{sec:int_mtask}

\subsection{Motivation}

Although the C++ code generation view works as expected, it poses a limitation. Tasks generated by this view are static: once they are compiled and uploaded, they can not be changed. If the user wishes to change the current task or add new tasks to the microcontroller, the program has to be recompiled and reuploaded. This presents two problems. First, microcontrollers have a limited amount of write cycles in their program memory~\cite{martthesis}. Therefore, the repeated uploading of new programs is not desired. Second, due to the nature of microcontrollers and the \ac{iot}, such devices are often located on places that are hard to reach. Therefore, it is not desirable that every time a new task has to be uploaded, the device has to be physically reached, plugged into a computer and put back in place.

To overcome that limitation, a new view of mTask was created~\cite{martthesis}. This view generates interpretable bytecode rather than C++ code. The bytecode can be interpreted by a runtime system in the device (the \textit{client}). This runtime system (also called the \textit{engine}), is written in C++ and can be compiled and uploaded using the Arduino IDE. Tasks and \acp{sds} are sent to the client dynamically. Therefore, devices are programmed once but can execute tasks dynamically. Additionally, this setting is more robust than the static mTask. If the communication with a device fails, the server can dynamically send the tasks that were running on it to another suitable device. 

\subsection{Communication Protocol}

Devices can be connected either via serial communication or TCP. The server and the client communicate via a protocol based on messages. Incoming messages are of type \texttt{MTaskMSGSend} --- messages are always named from the server's perspective. There are messages for task addition and deletion, shutdown request, \ac{sds} addition and update and specification request. The definition of the \texttt{MTaskMSGSend} \ac{adt} can be seen in Listing \ref{msg_send}.

\begin{lstlisting}[caption=Communication protocol: sent messages,captionpos=b,label=msg_send]
:: BCValue = E.e: BCValue e & mTaskType e

:: MTaskMSGSend = 
      MTTask MTaskInterval String
    | MTTaskDel Int
    | MTShutdown
    | MTSds Int BCValue
    | MTUpd Int BCValue
    | MTSpec
\end{lstlisting}

The client communicates with the server via messages of type \texttt{MTaskMSGRecv}. There are messages for task acknowledgment and deletion, \ac{sds} acknowledgment, deletion and publication, debugging messages, device specification and empty messages. The definition of the \texttt{MTaskMSGRecv} \ac{adt} can be seen in Listing \ref{msg_rec}. The \texttt{MTaskDeviceSpec} data type contains the specification of the device, i.e. its stack size, memory size, number of digital and analog pins.

\begin{lstlisting}[caption=Communication protocol: received messages,captionpos=b,label=msg_rec]
:: MTaskMSGRecv = 
      MTTaskAck Int Int
    | MTTaskDelAck Int
    | MTSDSAck Int
    | MTSDSDelAck Int
    | MTPub Int BCValue
    | MTMessage String
    | MTDevSpec MTaskDeviceSpec
    | MTEmpty
\end{lstlisting}

\subsection{The Client}

The client runs a loop function that runs repeatedly until a \textit{shutdown} message is received. The loop consists of two pieces: checking for incoming messages and running the task scheduler. The first step is straightforward: it checks the input buffer and processes any messages that might be in it. The task scheduler runs tasks based on task intervals. Tasks can run once (\texttt{OneShot}), repeatedly based on an interval (\texttt{OnInverval}) or based on an interruption (\texttt{OnInterrupt}). The interpreter is responsible for the execution of a task's bytecode.

\subsection{The Simulator}

During my Research Internship, I developed an iTask simulator for the interpreted mTask. The motivation behind it is the same as the simulator for the static mTask: programs running in microprocessors are hard to debug. The simulator mimics the C++ engine in many aspects, including communication, task scheduling and instruction interpretation. 

The simulator provides a web interface where the user can inspect the communication channels and the simulator state. The simulator state contains data about the simulator clock, memory, stack, tasks, \acp{sds} and peripherals (pins, LED, etc). The web interface allows peripheral values to be set manually. This is a great addition to the mTask development environment, given that sensor values can not be easily simulated on microcontrollers. In addition, users can set breakpoints on bytecode instructions and inspect the state of the simulator on specific points.

The simulator offers two modes: manual and automatic. Manual mode requires user interaction via the web interface to run. Manual simulation can be performed via either big or small steps. These two step options offer different levels of abstraction to the user. Big steps execute one entire engine loop at a time. Small steps execute each bytecode instruction individually. Automatic mode executes the simulator without the need of user interaction. It is particularly useful when the programmer needs to simulate a device but does not want to step manually through its execution. Many simulators on different modes can run simultaneously.

\section{Examples}

Two examples of mTask tasks can be seen in Listing \ref{mtask_examples}. The first example, \texttt{switch}, turns an LED on and off based on a switch connected to to digital pin \texttt{D0}. The second example, \texttt{curtains}, opens and closes curtains based on the room lighting. The curtains' controller is connected to digital pin \texttt{D0} and the light sensor is connected to analog pin \texttt{A0}. When the light sensor value is greater then 3, the curtains open. Otherwise, the curtains close. In addition, an alarm (represented by the \texttt{alarm} \ac{sds}) is triggered when the curtains open. Once the curtains open and the alarm is triggered, the task terminates.

\begin{lstlisting}[caption=Examples of mTask tasks,captionpos=b,label=mtask_examples]
switch :: Main (v () Stmt) 
switch = { main = 
	IF (dIO D0) (
		ledOn (lit LED1)
	) (
		ledOff (lit LED1)
	)}
	
curtains :: Main (v () Stmt)
curtains = sds \alarm=False In { main = 
	IF (aIO A0 >. lit 3) (
		dIO D0 =. (lit True) :.
		alarm =. lit True :.
		pub alarm :.
		retrn
	) (
		dIO D0 =. (lit False)
	)}
\end{lstlisting}

